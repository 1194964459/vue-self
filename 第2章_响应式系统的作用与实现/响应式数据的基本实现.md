# 响应式函数的基本实现

## 一、基本知识
**1. 副作用：** effect 函数的执行会*直接或间接影响其他函数的执行，这时我们说 函数产生了副作用* 

**2. 副作用函数：** 会产生副作用的函数
```js
// 全局变量
let val = 1
function effect() {
  val = 2 // 修改全局变量，产生副作用
}
```

**3. 响应式数据**
```js
const obj = { text: 'hello world' }
// 副作用函数
function effect() {
  // effect 函数的执行会读取 obj.text
  document.body.innerText = obj.text
}
```

```js
obj.text = 'hello vue3' // 修改 obj.text 的值，同时希望副作用函数会重新执行
```

**当值变化后，副作用函数会自动重新执行，那么对象 obj 就是响应式数据**

## 二、响应式数据的基本实现
*拦截一个对象的读取和设置操作：*
* 当**读取字段 obj.text** 时，我们可以**把副作用函数effect 存储到一个“桶”里**
* 当**设置 obj.text** 时，再把**副作用函数 effect 从“桶”里取出并执行**即可

```js
// 存储副作用函数的桶
const bucket = new Set()
// 原始数据
const data = { text: 'hello world' }

// 对原始数据的代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get(target, key) {
    // 将副作用函数 effect 添加到存储副作用函数的桶中
    bucket.add(effect)
    // 返回属性值
    return target[key]
  },
  // 拦截设置操作
  set(target, key, newVal) {
    // 设置属性值
    target[key] = newVal
    // 把副作用函数从桶里取出并执行
    bucket.forEach(fn => fn())
    // 返回 true 代表设置操作成功
    return true
  }
})
```
简单测试一下：
```js
// 副作用函数
function effect() {
  document.body.innerText = obj.text
}
// 执行副作用函数，触发读取
effect()
// 1 秒后修改响应式数据
setTimeout(() => {
  obj.text = 'hello vue3'
}, 1000)
```

## 三、完善的响应式系统
在“响应式数据基本实现”中有几点可以优化的：
1. 副作用函数(effect)是硬编码，一旦名字写错，上述代码就工作不了了 
    => 采用“注册副作用函数”机制
    => 这样，不管副作用是匿名函数，还是别的，都能正常工作？？？