# 非原始值的响应式方案

## 一、Proxy 与 Reflect
### 1. Proxy
* 使用 Proxy 可以创建一个代理对象。它能够实现**对其他对象的代理**。
* **Proxy 只能代理对象**，无法代理非对象值，例如字符串、布尔值等
* 所谓**代理，指的是对一个对象基本语义的代理**。它允许我们*拦截并重新定义对一个对象的基本操作*
```js
obj.fn()
```
这是个复合操作：
> * 基于get获取obj.fn属性
> * 对obj.fn进行函数调用

### 2. Reflect
Reflect 下的方法与 Proxy 的拦截器方法名字相同。任何在 Proxy 的拦截器中能够找到的方法，都能够在 Reflect 中找到同名函数。

既然操作等价，那么它存在的意义是什么呢？实际上 Reflect.get 函数还能接收第三个参数，即指定接收者 receiver，你可以把它理解为函数调用过程中的 this。

```js
const obj = { foo: 1 }
console.log(Reflect.get(obj, 'foo', { foo: 2 }))  // 输出的是 2 而不是 1
```

```js
const obj = {
  foo: 1,
  get bar() { // 访问器属性bar
    // 这里的 this 指向的是谁？
    return this.foo
  }
}
```

```js
effect(() => {
  console.log(p.bar) // 1
})
```

在副作用函数内通过原始对象访问它的某个属性是不会建立响应联系的
```js
effect(() => {
  // obj 是原始数据，不是代理对象，这样的访问不能够建立响应联系
  obj.foo
})
```
解决：用 Reflect.get()函数

```js
const p = new Proxy(obj, {
  // 拦截读取操作，接收第三个参数 receiver
  get(target, key, receiver) {
    track(target, key)
    // 使用 Reflect.get 返回读取到的属性值
    return Reflect.get(target, key, receiver)
  },
  // 省略部分代码
})
```
代理对象的 get 拦截函数接收第三个参数 receiver，它代表谁在读取属性。
例如：
```js
p.bar // 代理对象 p 在读取 bar 属性
```
当我们使用代理对象 p 访问 bar 属性时，那么 receiver就是 p。

此时，this 由原始对象 obj 变成了代理对象 p。很显然，这会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集的效果。

## 二、JS对象及Proxy的工作原理
内部方法具有多态性，这是什么意思呢？这类似于面向对象里多态的概念

如果**在创建代理对象时没有指定对应的拦截函数**，例如没有指定 get() 拦截函数，那么当我们通过代理对象访问属性值时，代理对象的内部方法 [​[Get]​] **会调用原始对象的内部方法** [​[Get]​] 来获取属性值，这其实就是**代理透明性质**。

**创建代理对象时指定的拦截函数，实际上是用来自定义*代理对象本身*的内部方法和行为的，而不是用来指定*被代理对象*的内部方法和行为的**

当我们要拦截删除属性操作时，可以使用 deleteProperty 拦截函数实现：
```js
const obj = { foo: 1 }
const p = new Proxy(obj, {
  deleteProperty(target, key) {
    return Reflect.deleteProperty(target, key)
  }
})

console.log(p.foo) // 1
delete p.foo
console.log(p.foo) // 未定义
```
*deleteProperty 实现的是代理对象 p的内部方法和行为*，所以为了删除*被代理对象*上的属性值，我们需要使用*Reflect.deleteProperty(target, key)来完成。*

## 三、如何代理Object
常见的读取操作：
* 访问属性：obj.foo
* 判断对象或原型上是否存在给定的 key：key in obj
* 使用 for...in 循环遍历对象：for (const key in obj){}
```js
effect(() => {
  'foo' in obj
})
```
如何拦截这些操作？



























## 浅响应与深响应
