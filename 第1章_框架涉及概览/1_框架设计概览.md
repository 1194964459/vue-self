# 第一章 框架设计概览

## 1. 命令式与声明式
早年间流行的 jQuery 就是典型的命令式框架。命令式框的一大特点就是关注过程。

```js
- 获取 id 为 app 的 div 标签
- 它的文本内容为 hello world
- 为其绑定点击事件
- 当点击时弹出提示：ok
```
用jQuery实现对应的代码为：
```js
$('#app') // 获取 div
  .text('hello world') // 设置文本内容
  .on('click', () => { alert('ok') }) // 绑定点击事件
```

用原生JavaScript实现对应的代码为：
```js
const div = document.querySelector('#app') // 获取 div
div.innerText = 'hello world' // 设置文本内容
div.addEventListener('click', () => { alert('ok') }) // 绑定点击事件
```
什么是声明式框架呢？**与命令式框架更加关注过程不同，声明式框架更加关注结果**。
```js
<div @click="() => alert('ok')">hello world</div>
```

结论：**Vue.js 帮我们封装了过程。因此，我们能够猜到 Vue.js 的内部实现一定是命令式的，而暴露给用户的却更加声明式。**

## 2. 性能与可维护性的权衡
声明式代码的性能不优于命令式代码的性能。

如果我们把直接修改的性能消耗定义为 A，把找出差异的性能消耗定义为 B，那么有：
* 命令式代码的更新性能消耗 = A
* 声明式代码的更新性能消耗 = B + A


既然在性能层面命令式代码是更好的选择，那么为什么Vue.js 要选择声明式的设计方案呢？**原因就在于声明式代码的可维护性更强。**

框架设计者要做的就是：**在保持可维护性的同时让性能损失最小化。**


## 3. 虚拟 DOM 的性能到底如何
**声明式代码的更新性能消耗 = 找出差异的性能消耗 + 直接修改的性能消耗**。而所谓的虚拟 DOM，就是为了**最小化找出差异这一步的性能消耗**而出现的。

理论上讲，**虚拟DOM 的更新技术的性能 不可能比原生 JavaScript操作 DOM 更高**。但这只是*理论上*，为什么呢？因为在大部分情况下，*我们很难写出绝对优化的命令式代码，尤其是当应用程序的规模很大的时候*，即使你写出了极致优化的代码，也一定耗费了巨大的精力，这时的投入产出比其实并不高。

疑问：使用 innerHTML 操作页面和虚拟 DOM 相比性能如何？
* innerHTML 创建页面的性能：HTML 字符串拼接的计算量 + innerHTML 的 DOM 计算量。