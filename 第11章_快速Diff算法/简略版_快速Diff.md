# 简略版快速Diff

## 一、算法流程解析
首先，借鉴纯文本 Diff算法思路，分别对头部、尾部进行预处理。

**1. 头部预处理**：从列表头部开始，while循环比较并复用相同的节点，直到遇到不同节点  
```js
let j = 0;  
while(newNode.key == oldNode.key){
    newNode = newChildren[j]
    ...
    j++
}
```

**2. 尾部预处理**：从列表尾部开始，while循环比较并复用相同的节点，直到遇到不同节点
```js
let oldEnd = oldChildren.length - 1   
let newEnd = newChildren.length - 1
while(newNode.key == oldNode.key){
    oldEnd--
    newEnd--
}
```
**3. 头部、尾部处理完后，可能某一方的列表已经处理完了**：
* 若旧节点已处理完了 但新节点没处理完，则批量“创建”剩余的新节点
* 若新节点已处理完了 但旧节点没处理完，则批量“移除”剩余的旧节点
```
跳出while循环
    若 j > oldEnd && j <= newEnd，则...
    若 j > newEnd && j <= oldEnd，则...
```

**4. 若上面的情况均不满足，则需要处理中间差异部分**：
* **构建索引表**：为新列表的节点建立 `key -> 索引` 的映射，便于快速查找。
* **遍历旧节点**：标记**可复用节点**（是否存在新列表中？存在 则复用）并**记录新节点在旧列表中的索引关系，形成“源数组source”**
* 根据source数组，**求最长递增子序列 seq**，序列指向的节点是不需要移动的。
* 根据 最长递增子序列(LIS) 的结果seq、source，**移动或创建节点**
```
seq：最长递增子序列，下标用 s 表示（从末尾开始）
source：新节点在旧列表中的索引，“下标”用 i 表示（从末尾开始），“长度”是新节点中经预处理后剩余节点的数量 newEnd-j+1，“初始值”为-1

迭代i
    若source[i] === -1，则索引 i 的节点是新节点，需挂载
    若source[i] !== -1，则继续判断：
        若seq[s]==i, 节点不需要移动，s--
        若seq[s]!=i，节点需要移动
```

## 二、关键优化解析
* 预处理阶段：通过头部和尾部的快速匹配，减少了需要详细比较的节点数量
* 最长递增子序列：这是 **Vue3 Diff 算法最核心的优化**，通过计算 LIS，可以**找到不需要移动的节点序列，从而将节点移动次数降到最低**
* 映射表查找：使用 key 建立映射表，快速查找可复用节点，避免了 Vue 2 中的多次循环比较

Vue 3 的 Diff 算法在保持 O(n) 时间复杂度的同时，通过 LIS 优化进一步减少了实际 DOM 操作次数，特别是在处理列表重排场景时性能提升显著。理解这些原理有助于我们写出更符合 Vue 3 优化策略的代码，例如在**使用 v-for 时合理设置 key**，以及设计更高效的列表更新逻辑。